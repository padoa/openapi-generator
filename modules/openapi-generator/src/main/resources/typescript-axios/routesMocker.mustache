/*
Ce fichier n'est pas utile en soit pour le package swagger.
Il est utilisé pour la génération du client ici: https://github.com/padoa/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/typescript-axios/
Avoir le fichier ici permet de le tester avec le package. En effet le repo openapi-generator n'a pas vraiment d'architecture de test
 */
import fs from 'fs';

import _ from 'lodash';
import nock from 'nock';

const DEFAULT_EXAMPLE_NAME = 'default';
const DEFAULT_EXAMPLE_STATUS = 200;
const DEFAULT_EXAMPLE_MOCK_CALL_COUNT = Infinity;

type HttpVerb = string;
type HttpStatus = number;

type Route = { httpVerb: HttpVerb; path: string };

type RoutesDataOpenApi = {
  [route: string]: {
    [httpVerb: string]: {
      responses: {
        [statusCode: number]: {
          content: {
            [requestType: string]: {
              scheme: Record<string, unknown>;
              examples?: Record<string, unknown>;
            };
          };
        };
      };
    };
  };
};

type RoutesMocks = {
  [route: string]: {
    [httpVerb: string]: {
      mockCallCount: number;
      currentExampleName: string;
      currentStatusCode: number;
      [statusCode: number]: { examples: Record<string, { value: Record<string, unknown> }> };
    };
  };
};

export class RoutesMocker {
  private readonly routeMocks: RoutesMocks;
  private runningNockMocks: Record<string, Record<string, nock.Interceptor>>;
  private rootHttpPath: string;

  constructor(openApiFilepath: string = '/local/swagger.json') {
    // eslint-disable-next-line no-sync
    const routeMocks: RoutesDataOpenApi = JSON.parse(fs.readFileSync(openApiFilepath).toString()).paths;

    this.rootHttpPath = process.env.ROUTE_MOCKER_{{npmName}} || 'http://localhost';

    const nestedMockRoutes = Object.entries(routeMocks).map(([routePath, routeData]) => {
      return Object.entries(routeData).map(([httpVerb, verbData]) => {
        return Object.entries(verbData.responses).map(([statusCode, responseData]) => {
          const requestTypes = Object.keys(responseData.content);
          /* istanbul ignore if */
          if (requestTypes.length !== 1) {
            throw new Error(
              `Can't handle multiple request type ${requestTypes} for route ${routePath} with verb ${httpVerb} and statusCode ${statusCode}`,
            );
          }

          const examples = responseData.content[requestTypes[0]]?.examples;
          if (!examples) {
            return {};
          }

          return {
            [routePath]: {
              [httpVerb.toUpperCase()]: {
                [statusCode]: { examples },
                mockCallCount: DEFAULT_EXAMPLE_MOCK_CALL_COUNT,
                currentExampleName: DEFAULT_EXAMPLE_NAME,
                currentStatusCode: DEFAULT_EXAMPLE_STATUS,
              },
            },
          };
        });
      });
    });

    this.routeMocks = Object.assign({}, ..._.flattenDeep(nestedMockRoutes));
    this.runningNockMocks = {};
  }

  private startAMock(mockRoutePath: string, mockVerb: HttpVerb): void {
    const { mockCallCount, currentExampleName, currentStatusCode } = this.routeMocks[mockRoutePath][mockVerb];

    const exampleData = this.routeMocks[mockRoutePath][mockVerb][currentStatusCode].examples[currentExampleName].value;

    // https://github.com/nock/nock#http-verbs
    const nockMockInterceptor = nock(this.rootHttpPath).intercept(mockRoutePath, mockVerb).times(mockCallCount);

    nockMockInterceptor.reply(currentStatusCode, exampleData);

    this.runningNockMocks = { ...this.runningNockMocks, [mockRoutePath]: { [mockVerb]: nockMockInterceptor } };
  }

  private stopAMock(mockRoutePath: string, mockVerb: HttpVerb): void {
    nock.removeInterceptor(this.runningNockMocks[mockRoutePath][mockVerb]);

    delete this.runningNockMocks[mockRoutePath][mockVerb];
    /* istanbul ignore else */
    if (Object.keys(this.runningNockMocks[mockRoutePath]).length === 0) {
      delete this.runningNockMocks[mockRoutePath];
    }
  }

  private restartAMock(mockRoutePath: string, mockVerb: HttpVerb): void {
    const existingMock = this.runningNockMocks?.[mockRoutePath]?.[mockVerb];
    /* istanbul ignore else */
    if (existingMock) {
      this.stopAMock(mockRoutePath, mockVerb);
    }
    this.startAMock(mockRoutePath, mockVerb);
  }

  public startAllMocks(): void {
    Object.entries(this.routeMocks).forEach(([routePath, routePathValues]) => {
      Object.keys(routePathValues).forEach((httpVerb) => {
        this.startAMock(routePath, httpVerb);
      });
    });
  }

  public stopAllMocks(): void {
    nock.cleanAll();
    this.runningNockMocks = {};
  }

  public restartAllMocks(): void {
    this.stopAllMocks();
    this.startAllMocks();
  }

  public changeRouteExample(
    route: Route,
    {
      numberOfCall = DEFAULT_EXAMPLE_MOCK_CALL_COUNT,
      exampleName = DEFAULT_EXAMPLE_NAME,
      httpStatus = DEFAULT_EXAMPLE_STATUS,
    }: { httpStatus?: HttpStatus; exampleName?: string; numberOfCall?: number } = {},
  ): void {
    const httpVerb = route.httpVerb.toUpperCase();
    const theRouteMock = this.routeMocks[route.path][httpVerb];

    if (!theRouteMock?.[httpStatus]?.examples?.[exampleName]) {
      throw new Error(`Route ${route.path} with verb ${httpVerb} doesn't have example with name ${exampleName} with status ${httpStatus}`);
    }

    theRouteMock.mockCallCount = numberOfCall;
    theRouteMock.currentExampleName = exampleName;
    theRouteMock.currentStatusCode = httpStatus;

    this.restartAMock(route.path, httpVerb);
  }
}
